/************** <<<<<<<<Applicaton code for our Graduation Project>>>>>>>> ***************/

#include "STD_TYPES.h"
#include "RCC_interface.h"
#include "GPIO_interface.h"
#include "NVIC_interface.h"
#include "Timer_interface.h"
#include "USART_interface.h"

/*Constant for conversion from rpm to */
const u32 rpm_to_radians = 0.10471975512;

/*Global variables for angular velocities (radians per second) for the two motors*/
u32 right_radian_per_second =0;
u32 left_radian_per_second  =0;

u8 PWM_right_motor=0;
u8 PWM_left_motor=0;

void readEncoder(void)
{
	u32 right_local_u32_motor=0;
	u32 left_local_u32_motor=0;

	right_local_u32_motor= TimerX_GetCount(TIMER_2_);
	left_local_u32_motor = TimerX_GetCount(TIMER_4_);

	/*Get rpm:
	 * get no. of revolutions per second by dividing the counter value by 1600
	 * get the rpm by multiplying by 60
	 * */
	right_local_u32_motor = (right_local_u32_motor/1600.0) * 60.0;
	left_local_u32_motor  = (left_local_u32_motor/1600.0) * 60.0;

	/*Convert from rpm to radians*/
	right_radian_per_second = right_local_u32_motor * rpm_to_radians;
	left_radian_per_second  = left_local_u32_motor  * rpm_to_radians;
}

void getVelocity()
{
	static u8 last_byte_index= "r";
	u8 local_u8_data= MSUART_u8ReadDataRegister(2);

	switch(local_u8_data)
	{
		case 'r':
			last_byte_index = local_u8_data;
			break;
		case 'l':
			last_byte_index = local_u8_data;
			break;
		default:
			last_byte_index = 0;
			break;

	}

	if(last_byte_index == 'r')
	{
		PWM_right_motor = local_u8_data;
	}
	if(last_byte_index == 'l')
	{
		PWM_left_motor = local_u8_data;
	}
}

int main(void)
{

	/*The initialization struct for UART 3*/
	USART_Init_struct Uart_t_Initialization;
	/*2 stands for USART 3 */
	Uart_t_Initialization.UartNo= 2;
	Uart_t_Initialization.Word_Length= Data_9_Bits;
	Uart_t_Initialization.Parity= Odd_Parity;
	Uart_t_Initialization.Baud_Rate= BaudRate_19200;
	Uart_t_Initialization.Stop_Bits= One_Stop_Bit;
	Uart_t_Initialization.Mode= Asynchronous;

	/*Initialize system clock*/
	RCC_voidInitSystemClock();

	/*Enable clock for the used peripheral*/
	/*Enable clock for GPIOA*/
	RCC_voidEnableCompClk(RCC_AHB1,RCC_AHB1_GPIOA);

	/*Enable clock for Timers from 2 to 5*/
	RCC_voidEnableCompClk(RCC_APB1,RCC_APB1_TIM2);
	RCC_voidEnableCompClk(RCC_APB1,RCC_APB1_TIM3);
	RCC_voidEnableCompClk(RCC_APB1,RCC_APB1_TIM4);
	RCC_voidEnableCompClk(RCC_APB1,RCC_APB1_TIM5);

	/*Enable clock for UART 3*/
	RCC_voidEnableCompClk(RCC_APB1,RCC_APB1_USART3);

	/*Set alternating functions pins*/
	/*PWM Pins*/
	GPIO_voidSetAlternatingFunction(GPIOA,PIN0,AF2);
	GPIO_voidSetAlternatingFunction(GPIOA,PIN1,AF2);

	/*Initialize NVIC*/
	NVIC_Init();

	/*Initialize UART 3*/
	MUSART_voidInit(&Uart_t_Initialization);
	/*Enable UART receive interrupt*/
	MSUART_voidInterrupt(2,USART_RxDataNotEmptyInt,USART_Interrupt_Enable);
	/*Get the PWM value for the motors velocity from the received data from UART*/
	MUSART3_voidSetCallBack(getVelocity);

	/*Enable encoder mode on timer 2 for right motor */
	TimerX_EncoderMode(TIMER_2_);
	/*Enable encoder mode on timer 4 for left motor */
	TimerX_EncoderMode(TIMER_4_);

	/*Enable timer 3 to generate an interrupt every 1 sec*/
	TimerX_Count(TIMER_3_,UP_COUNTER,1000);
	/*Get the angular velocity from encoder every 1 sec*/
	Timer3_voidSetCallBack(readEncoder);

	/*Initialize PWM on right motor with duty cycle 20% as a start*/
	TimerX_PWM(TIMER_5_,CH1,20);
	/*Initialize PWM on left motor with duty cycle 20% as a start*/
	TimerX_PWM(TIMER_5_,CH2,20);

	while(1)
	{

	}

	return 1;
}
